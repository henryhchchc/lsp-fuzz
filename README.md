# LSPFuzz: Hunting Bugs in Language Servers

LSPFuzz is a grey-box hybrid fuzzer that generates test cases for [Language Servers](https://microsoft.github.io/language-server-protocol/).
It is implemented based on [LibAFL](https://github.com/AFLplusplus/LibAFL).

## Technical Details

To understand how LFPFuzz works, please checkout the following research paper:

Hengcheng Zhu, Songqiang Chen, Valerio Terragni, Lili Wei, Jiarong Wu, Yepang Liu, and Shing-Chi Cheung.
**LSPFuzz: Hunting Bugs in Language Servers.**
In _Proceedings of the 40<sup>th</sup> IEEE/ACM International Conference on Automated Software Engineering._ Seoul, South Korea. November 2025.

[ðŸŽ¤Conference](https://conf.researchr.org/details/ase-2025/ase-2025-papers/203/LSPFuzz-Hunting-Bugs-in-Language-Servers)
| [ðŸ“„Preprint](https://scholar.henryhc.net/files/publications/2025/ASE2025-LSPFuzz.pdf)
| [ðŸ“¦Artifacts](https://doi.org/10.5281/zenodo.17052142)

If you use LSPFuzz for academic purposes, please cite the above paper.

## Usage

### Preparation

1. Prepare a fuzz target compatible with [AFL++](https://github.com/AFLplusplus/AFLplusplus).
   It is highly recommended to use the [LTO mode](https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.lto.md) and [persistent mode](https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md).
   The following is an annotated template for a fuzz target.

   ```c++
   #include "your_header_file.h"

   #ifndef __AFL_FUZZ_TESTCASE_LEN
    // The following definitions allow compilation without the AFL++ compiler.
    ssize_t fuzz_len;
    #define __AFL_FUZZ_TESTCASE_LEN fuzz_len
    const uint8_t fuzz_buf[1024000];
    #define __AFL_FUZZ_TESTCASE_BUF fuzz_buf
    #define __AFL_FUZZ_INIT() void sync(void);
    #define __AFL_LOOP(x) ((fuzz_len = read(0, fuzz_buf, sizeof(fuzz_buf))) > 0 ? 1 : 0)
    #define __AFL_INIT() sync()
   #endif

   __AFL_FUZZ_INIT();

   int main(int argc, const char* argv[]) {

    #ifdef __AFL_HAVE_MANUAL_CONTROL
      __AFL_INIT();
    #endif

    // [Initialization]
    // Perform some one-time initialization for the target LSP server.
    // Or call `LLVMFuzzerInitialize(argc, argv)` here.

    const uint8_t *buf = __AFL_FUZZ_TESTCASE_BUF;
    while (__AFL_LOOP(10000)) {
        ssize_t len = __AFL_FUZZ_TESTCASE_LEN;
        // [Input Processing]
        // Process an input here:
        //   1. Read `len` bytes from `buf` for LSP inputs, as if they were read from `stdin`.
        //   2. Process the LSP inputs. Note that the input contains the `Content-Length` headers.
        //   3. Release resources and reset states
        // Or call `LLVMFuzzerTestOneInput(buf, len)` here.
    }
    return 0;
   }
   ```

> [!NOTE]
> Although persistent mode can significantly improve the fuzzing efficiency, users need to make sure the resource are properly released and states are reset in the fuzzing loop.

2. Obtaining the coverage map size

```bash
AFL_DUMP_MAP_SIZE=1 ./fuzz-target
```

3. Mine code fragments for code generation.

```bash
lsp-fuzz-cli mine-code-fragments \
  --search-directory <code-dir> \ # A directory containing code files of the target language of the LSP servers
  --output <fragment-output> # The file to store the mined code fragments
```

### Start Fuzzing

```bash
lsp-fuzz-cli fuzz \
  --state <state-dir> \ # The directory to store the fuzzing state (e.g., generated inputs, found crashes)
  --lsp-executable <fuzz-target> \ # The executable file of the LSP server to fuzz target
  --language-fragments Language=<fragment-output>\ # Comma-separated list of files containing the mined code fragments, for example, `C=c.frag,CPlusPlus=cpp.frag`
  --coverage-map-size <coverage-map-size> \ # The size of the coverage map to use for coverage-guided fuzzing
  --time-budget 24 # The time budget for fuzzing in hours
```

To lean more about the options, run `lsp-fuzz-cli fuzz --help`.

### Reproduce Detected Crashes

1. Export the generated crash inducing inputs

```bash
lsp-fuzz-cli export \
  --input <state-dir>/solutions \ # The directory containing the generated crash inducing inputs
  --output <export-directory> # The directory to store the exported crash inducing inputs
```

The contents of `<export-directory>` will be organized as follows:

```
<export-directory>
â”œâ”€â”€ <input-id-1>
â”‚   â”œâ”€â”€ workspace
â”‚   â”‚   â”œâ”€â”€ file1.txt
â”‚   â”‚   â””â”€â”€ file2.txt
â”‚   â””â”€â”€ requests
â”‚       â”œâ”€â”€ message_0001
â”‚       â””â”€â”€ message_0002
â”œâ”€â”€ <input-id-2>
â”‚   â”œâ”€â”€ workspace
â”‚   â”‚   â”œâ”€â”€ file1.txt
â”‚   â”‚   â””â”€â”€ file2.txt
â”‚   â””â”€â”€ requests
â”‚       â”œâ”€â”€ message_0001
â”‚       â””â”€â”€ message_0002
â””â”€â”€ ...
```

Each directory `<input-id>` represents a unique input generated by LSPFuzz.
Within each `<input-id>` directory, there are two subdirectories: `workspace` and `requests`.
The `workspace` directory contains the code files, and the `requests` directory contains the LSP requests that were sent to the LSP server during the fuzzing process.

> [!NOTE]
> Do not move the exported test cases because the LSP requests are encoded with _absolute paths_, moving them will invalidate the requests.

2. Feed the exported input to the LSP server

To reproduce the crash, `cd` to a directory containing the exported inputs.

```bash
cat requests/* | ./target-lsp-server
```

Note that `target-lsp-server` is the actual LSP server under test, not the fuzz target.
Make sure it reads requests from `stdin`.
To reproduce bugs caught by sanitizers, `target-lsp-server` should be compiled with sanitizers enabled.
