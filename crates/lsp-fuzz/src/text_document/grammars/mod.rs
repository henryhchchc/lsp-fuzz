use std::collections::HashMap;

use itertools::Itertools;
use tree::NodeIter;

use super::Language;

pub use crate::stolen::tree_sitter_generate::*;

/// The C grammar generated by tree-sitter
pub const C_GRAMMAR_JSON: &str = include_str!("tree_sitter/c.json");
#[derive(Debug)]
pub struct Grammar {
    language: Language,
    ts_language: tree_sitter::Language,
    grammar: SyntaxGrammar,
    derivation_fragments: HashMap<String, Vec<u8>>,
}

/// Extracts derivation fragments from the given source code using the provided parser.
///
/// This function parses the provided source code and traverses the resulting parse tree
/// to extract fragments of the code associated with each node type. The fragments are
/// grouped by their node types and returned as a `HashMap`.
///
/// # Arguments
///
/// * `code` - A byte slice representing the source code to be parsed.
/// * `parser` - A mutable reference to a `tree_sitter::Parser` used to parse the code.
///
/// # Returns
///
/// A `HashMap` where the keys are static string slices representing the node types,
/// and the values are vectors of byte slices representing the fragments of the code
/// associated with each node type.
pub fn extract_derivation_fragments<'c>(
    code: &'c [u8],
    parser: &mut tree_sitter::Parser,
) -> HashMap<&'static str, Vec<&'c [u8]>> {
    let Some(tree) = parser.parse(code, None) else {
        return HashMap::new();
    };

    tree.root_node()
        .iter_depth_first()
        .map(|it| {
            let kind = it.kind();
            let fragment = &code[it.byte_range()];
            (kind, fragment)
        })
        .into_group_map()
}

pub mod tree;

#[cfg(test)]
mod test {
    use super::extract_derivation_fragments;

    const C_CODE: &str = r#"
    #include <stdio.h>
    #include <stdlib.h>

    const int x = 42;

    int main(int argc, char *argv[] "\n") {
        printf("Hello, world!\n");
        return 0;
    }
    "#;

    #[test]
    fn test_extract_derivation_fragments() {
        let mut parser = tree_sitter::Parser::new();
        let lang = tree_sitter_c::LANGUAGE.into();
        parser.set_language(&lang).unwrap();
        let fragments = extract_derivation_fragments(C_CODE.as_bytes(), &mut parser);
        for key in [
            "translation_unit",
            "function_definition",
            "declaration",
            "expression_statement",
            "call_expression",
            "string_literal",
            "number_literal",
        ] {
            assert!(fragments.contains_key(key), "{key} not found");
        }
        assert!(fragments["number_literal"].contains(&b"42".as_slice()));
    }
}
