use core::fmt;
use std::{
    collections::{HashMap, HashSet},
    fmt::{Display, Formatter},
};

use anyhow::bail;
pub mod tree;
use itertools::{Either, Itertools};
pub mod fragment_extraction;

use crate::stolen::tree_sitter_generate;

use super::Language;

/// The C grammar generated by tree-sitter
pub const C_GRAMMAR_JSON: &str = include_str!("tree_sitter/c.json");

/// The Rust grammar generated by tree-sitter
pub const RUST_GRAMMAR_JSON: &str = include_str!("tree_sitter/rust.json");

#[derive(Debug, Hash, PartialEq, Eq, derive_more::Display)]
pub enum Terminal {
    #[display("\"{}\"", String::from_utf8_lossy(_0).escape_default())]
    Immediate(Vec<u8>),
    #[display("[{_0}]")]
    Named(String),
    #[display("({_0})")]
    Auxiliary(String),
}

#[derive(Debug, Hash, PartialEq, Eq, derive_more::Display)]
pub enum Symbol {
    Terminal(Terminal),
    #[display("<{_0}>")]
    NonTerminal(String),
    #[display("<EOF>")]
    Eof,
}

#[derive(Debug, Hash, PartialEq, Eq, derive_more::IntoIterator)]
pub struct Derivation {
    #[into_iterator(owned, ref, ref_mut)]
    symbols: Vec<Symbol>,
}

impl Display for Derivation {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if self.symbols.is_empty() {
            write!(f, "Îµ")
        } else {
            write!(f, "{}", self.symbols.iter().format(" "))
        }
    }
}

impl Derivation {
    pub fn new(symbols: Vec<Symbol>) -> Self {
        Self { symbols }
    }

    pub fn symbols(&self) -> &[Symbol] {
        &self.symbols
    }
}

#[derive(Debug, derive_more::Constructor)]
pub struct DerivationGrammar {
    language: Language,
    start_symbol: String,
    derivation_rules: HashMap<String, HashSet<Derivation>>,
}

impl Display for DerivationGrammar {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "Grammar for {}", self.language)?;
        writeln!(f, "Start symbol: <{}>", self.start_symbol)?;
        writeln!(f, "Production rules:")?;
        for (symbol, derivations) in &self.derivation_rules {
            writeln!(
                f,
                "<{}> ::=\n    {}\n",
                symbol,
                derivations.iter().format("\n  | ")
            )?;
        }
        writeln!(f)?;
        Ok(())
    }
}

impl DerivationGrammar {
    pub fn derivation_rules(&self) -> &HashMap<String, HashSet<Derivation>> {
        &self.derivation_rules
    }
}

impl DerivationGrammar {
    pub fn from_tree_sitter_grammar_json(
        language: Language,
        grammar_json: &str,
    ) -> Result<Self, CreationError> {
        let input_grammar =
            tree_sitter_generate::parse_grammar(grammar_json).map_err(CreationError::TreeSitter)?;
        let (syntax_grammar, lexical_grammar, aliases) =
            tree_sitter_generate::prepare_grammar(&input_grammar)
                .map_err(CreationError::TreeSitter)?;
        Self::from_tree_sitter_grammar(language, syntax_grammar, lexical_grammar, aliases)
    }

    pub fn validate(&self) -> Result<(), anyhow::Error> {
        for symbol in self.derivation_rules.values().flatten().flatten() {
            match symbol {
                Symbol::NonTerminal(ref name) if !self.derivation_rules.contains_key(name) => {
                    bail!("Missing rule for non-terminal symbol: {}", name);
                }
                _ => {}
            }
        }
        Ok(())
    }
}

#[derive(Debug, thiserror::Error)]
pub enum CreationError {
    #[error("Error occurred in tree-sitter: {0}")]
    TreeSitter(anyhow::Error),
    #[error("The provided grammar is empty")]
    EmptyGrammar,
    #[error("The grammar is missing a rule")]
    MissingRule,
}

#[derive(Debug)]
pub struct GrammarContext {
    grammar: DerivationGrammar,
    ts_language: tree_sitter::Language,
    derivation_fragments: HashMap<String, Vec<Vec<u8>>>,
}

impl GrammarContext {
    pub fn parse_source_code(
        &self,
        source_code: impl AsRef<[u8]>,
    ) -> Result<tree_sitter::Tree, tree_sitter::LanguageError> {
        let mut parser = tree_sitter::Parser::new();
        parser.set_language(&self.ts_language)?;
        let tree = parser.parse(source_code, None).expect("Garenteed by API");
        Ok(tree)
    }

    pub fn derivation_fragment(&self, node_kind: &str) -> impl Iterator<Item = &[u8]> {
        let Some(fragments) = self.derivation_fragments.get(node_kind) else {
            return Either::Left(std::iter::empty());
        };
        Either::Right(fragments.iter().map(|it| it.as_slice()))
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn load_derivation_grammar_c() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::C, C_GRAMMAR_JSON).unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }

    #[test]
    fn load_derivation_grammar_rust() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::Rust, RUST_GRAMMAR_JSON)
                .unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }
}
