use core::fmt;
use std::{
    borrow::Cow,
    cell::OnceCell,
    collections::{HashMap, HashSet},
    fmt::{Display, Formatter},
    ops::Range,
};

use anyhow::bail;
pub mod tree;
use indexmap::{IndexMap, IndexSet};
use itertools::{Either, Itertools};
use libafl_bolts::rands::Rand;
use serde::{Deserialize, Serialize};
pub mod fragment_extraction;

use crate::stolen::tree_sitter_generate;

use super::Language;

/// The C grammar generated by tree-sitter
pub const C_GRAMMAR_JSON: &str = include_str!("tree_sitter/c.json");

/// The Rust grammar generated by tree-sitter
pub const RUST_GRAMMAR_JSON: &str = include_str!("tree_sitter/rust.json");

#[derive(Debug, Hash, PartialEq, Eq, Serialize, Deserialize, derive_more::Display)]
pub enum Terminal {
    #[display("\"{}\"", String::from_utf8_lossy(_0).escape_default())]
    Immediate(Vec<u8>),
    #[display("[{_0}]")]
    Named(String),
    #[display("({_0})")]
    Auxiliary(String),
}

#[derive(Debug, Hash, PartialEq, Eq, Serialize, Deserialize, derive_more::Display)]
pub enum Symbol {
    Terminal(Terminal),
    #[display("<{_0}>")]
    NonTerminal(String),
    #[display("<EOF>")]
    Eof,
}

#[derive(Debug, Hash, PartialEq, Eq, Serialize, Deserialize, derive_more::IntoIterator)]
pub struct Derivation {
    #[serde(flatten)]
    #[into_iterator(owned, ref, ref_mut)]
    symbols: Vec<Symbol>,
}

impl Display for Derivation {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if self.symbols.is_empty() {
            write!(f, "Îµ")
        } else {
            write!(f, "{}", self.symbols.iter().format(" "))
        }
    }
}

impl Derivation {
    pub fn new(symbols: Vec<Symbol>) -> Self {
        Self { symbols }
    }

    pub fn symbols(&self) -> &[Symbol] {
        &self.symbols
    }
}

#[derive(Debug, PartialEq, Eq, Serialize, Deserialize, derive_more::Constructor)]
pub struct DerivationGrammar {
    language: Language,
    start_symbol: String,
    derivation_rules: IndexMap<String, IndexSet<Derivation>>,
}

impl Display for DerivationGrammar {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "Grammar for {}", self.language)?;
        writeln!(f, "Start symbol: <{}>", self.start_symbol)?;
        writeln!(f, "Production rules:")?;
        for (symbol, derivations) in &self.derivation_rules {
            writeln!(
                f,
                "<{}> ::=\n    {}\n",
                symbol,
                derivations.iter().format("\n  | ")
            )?;
        }
        writeln!(f)?;
        Ok(())
    }
}

impl DerivationGrammar {
    pub fn derivation_rules(&self) -> &IndexMap<String, IndexSet<Derivation>> {
        &self.derivation_rules
    }
}

impl DerivationGrammar {
    pub fn from_tree_sitter_grammar_json(
        language: Language,
        grammar_json: &str,
    ) -> Result<Self, CreationError> {
        let input_grammar =
            tree_sitter_generate::parse_grammar(grammar_json).map_err(CreationError::TreeSitter)?;
        let (syntax_grammar, lexical_grammar, aliases) =
            tree_sitter_generate::prepare_grammar(&input_grammar)
                .map_err(CreationError::TreeSitter)?;
        Self::from_tree_sitter_grammar(language, syntax_grammar, lexical_grammar, aliases)
    }

    pub fn validate(&self) -> Result<(), anyhow::Error> {
        for symbol in self.derivation_rules.values().flatten().flatten() {
            match symbol {
                Symbol::NonTerminal(ref name) if !self.derivation_rules.contains_key(name) => {
                    bail!("Missing rule for non-terminal symbol: {}", name);
                }
                _ => {}
            }
        }
        Ok(())
    }
}

#[derive(Debug, thiserror::Error)]
pub enum CreationError {
    #[error("Error occurred in tree-sitter: {0}")]
    TreeSitter(anyhow::Error),
    #[error("The provided grammar is empty")]
    EmptyGrammar,
    #[error("The grammar is missing a rule")]
    MissingRule,
}

#[derive(Debug, Serialize, Deserialize, derive_more::Constructor)]
pub struct DerivationFragments {
    code: Vec<u8>,
    fragments: HashMap<Cow<'static, str>, HashSet<Range<usize>>>,
}

impl DerivationFragments {
    pub fn get(&self, node_kind: &str) -> Option<impl ExactSizeIterator<Item = &[u8]>> {
        let ranges = self.fragments.get(node_kind)?;
        Some(ranges.iter().cloned().map(|range| &self.code[range]))
    }
}

#[derive(Debug, Serialize, Deserialize, derive_more::Constructor)]
pub struct GrammarContext {
    grammar: DerivationGrammar,
    derivation_fragments: DerivationFragments,
}

impl GrammarContext {
    pub fn parse_source_code(
        &self,
        source_code: impl AsRef<[u8]>,
    ) -> Result<tree_sitter::Tree, tree_sitter::LanguageError> {
        let mut parser = tree_sitter::Parser::new();
        parser.set_language(&self.grammar.language.ts_language())?;
        let tree = parser.parse(source_code, None).expect("Garenteed by API");
        Ok(tree)
    }

    pub fn language(&self) -> Language {
        self.grammar.language
    }

    pub fn update_parse_tree<'a>(
        &self,
        buffer: &'a [u8],
        tree: &'a mut tree_sitter::Tree,
        node: tree_sitter::Node<'a>,
        replacement: &[u8],
    ) {
        let mut parser = tree_sitter::Parser::new();
        parser
            .set_language(&self.grammar.language.ts_language())
            .unwrap();
        let input_edit = edit_for_node_replacement(node, replacement);
        tree.edit(&input_edit);
        *tree = parser.parse(buffer, Some(tree)).unwrap();
    }

    pub fn derivation_fragment(&self, node_kind: &str) -> impl ExactSizeIterator<Item = &[u8]> {
        if let Some(fragments) = self.derivation_fragments.get(node_kind) {
            Either::Right(fragments)
        } else {
            Either::Left(std::iter::empty())
        }
    }

    pub fn generate_node(
        &self,
        node_kind: &str,
        rand: &mut impl Rand,
        max_depth: Option<usize>,
    ) -> Result<Vec<u8>, DerivationError> {
        let derivation_fragments = self.derivation_fragment(node_kind);
        let has_derivation_rule = self.grammar.derivation_rules.contains_key(node_kind);
        let has_derivation_fragments = derivation_fragments.len() > 0;
        let depth_limit_reached = max_depth.is_some_and(|it| it == 0);
        let should_derive = match (
            depth_limit_reached,
            has_derivation_rule,
            has_derivation_fragments,
        ) {
            (true, _, false) => return Err(DerivationError::DepthLimitReached),
            (_, false, true) => false,
            (true, _, true) => false,
            (false, true, false) => true,
            (false, true, true) => rand.coinflip(0.5),
            (false, false, false) => return Err(DerivationError::InvalidGrammar),
        };
        if should_derive {
            let derivation_rules = self
                .grammar
                .derivation_rules()
                .get(node_kind)
                .expect("We checked that the rule is available");
            let rule = rand
                .choose(derivation_rules)
                .ok_or(DerivationError::InvalidGrammar)?;
            rule.into_iter()
                .map(|symbol| match symbol {
                    Symbol::NonTerminal(ref name) => {
                        self.generate_node(name, rand, max_depth.map(|it| it - 1))
                    }
                    Symbol::Terminal(ref term) => match term {
                        Terminal::Immediate(content) => Ok(content.to_vec()),
                        Terminal::Named(name) | Terminal::Auxiliary(name) => {
                            let fragments = self.derivation_fragment(name);
                            let fragment = rand
                                .choose(fragments)
                                .ok_or(DerivationError::InvalidGrammar)?;
                            Ok(fragment.to_vec())
                        }
                    },
                    Symbol::Eof => Ok(Vec::default()),
                })
                .flatten_ok()
                .collect::<Result<Vec<_>, _>>()
        } else {
            let fragments = self.derivation_fragment(node_kind);
            let fragment = rand
                .choose(fragments)
                .ok_or(DerivationError::InvalidGrammar)?;
            Ok(fragment.to_vec())
        }
    }
}

#[derive(Debug, thiserror::Error)]
pub enum DerivationError {
    #[error("The depth limit has been reached")]
    DepthLimitReached,
    #[error("The grammar is invalid")]
    InvalidGrammar,
}

fn edit_for_node_replacement<'a>(
    node: tree_sitter::Node<'a>,
    replacement: &[u8],
) -> tree_sitter::InputEdit {
    let start_byte = node.start_byte();
    let old_end_byte = node.end_byte();
    let start_position = node.start_position();
    let old_end_position = node.end_position();
    let (delta_rows, delta_cols) = measure_fragment::<b'\n'>(replacement);
    let new_end_position = tree_sitter::Point {
        row: old_end_position.row + delta_rows,
        column: if delta_rows == 0 {
            old_end_position.column + delta_cols
        } else {
            delta_cols
        },
    };
    let new_end_byte = start_byte + replacement.len();
    tree_sitter::InputEdit {
        start_byte,
        old_end_byte,
        new_end_byte,
        start_position,
        old_end_position,
        new_end_position,
    }
}

fn measure_fragment<const LINE_SEP: u8>(fragment: &[u8]) -> (usize, usize) {
    let mut rows = 0;
    let mut cols = 0;
    for &byte in fragment.iter().rev() {
        if byte == LINE_SEP {
            rows += 1;
            cols = 0;
        } else if rows == 0 {
            cols += 1;
        }
    }
    (rows, cols)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_measure_fragment_single_line() {
        // Test case 1: Single line, no separators
        let fragment = b"hello";
        let (rows, cols) = measure_fragment::<b'\n'>(fragment);
        assert_eq!(rows, 0);
        assert_eq!(cols, 5);
    }

    #[test]
    fn test_measure_fragment_two_lines() {
        // Test case 2: Two lines
        let fragment = b"hello\nworld";
        let (rows, cols) = measure_fragment::<b'\n'>(fragment);
        assert_eq!(rows, 1);
        assert_eq!(cols, 5);
    }

    #[test]
    fn test_measure_fragment_ends_with_separator() {
        // Test case 3: Ends with separator
        let fragment = b"hello\nworld\n";
        let (rows, cols) = measure_fragment::<b'\n'>(fragment);
        assert_eq!(rows, 2);
        assert_eq!(cols, 0);
    }

    #[test]
    fn test_measure_fragment_empty_fragment() {
        // Test case 4: Empty fragment
        let fragment = b"";
        let (rows, cols) = measure_fragment::<b'\n'>(fragment);
        assert_eq!(rows, 0);
        assert_eq!(cols, 0);
    }

    #[test]
    fn load_derivation_grammar_c() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::C, C_GRAMMAR_JSON).unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }

    #[test]
    fn load_derivation_grammar_rust() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::Rust, RUST_GRAMMAR_JSON)
                .unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }
}
