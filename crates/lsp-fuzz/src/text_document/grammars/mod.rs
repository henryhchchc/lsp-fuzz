use core::fmt;
use std::{
    collections::HashMap,
    fmt::{Display, Formatter},
};

use itertools::{Either, Itertools};
use tree::NodeIter;

use crate::stolen::tree_sitter_generate;

use super::Language;

/// The C grammar generated by tree-sitter
pub const C_GRAMMAR_JSON: &str = include_str!("tree_sitter/c.json");

#[derive(Debug, derive_more::Display)]
pub enum Terminal {
    #[display("\"{}\"", String::from_utf8_lossy(_0).escape_default())]
    Literal(Vec<u8>),
    #[display("<{_0}>")]
    Named(String),
    #[display("[{_0}]")]
    Auxillary(String),
}

#[derive(Debug, derive_more::Display)]
pub enum Symbol {
    Terminal(Terminal),
    #[display("<{_0}>")]
    NonTerminal(String),
    #[display("<EOF>")]
    Eof,
}

#[derive(Debug)]
pub struct Derivation {
    symbols: Vec<Symbol>,
}

impl Display for Derivation {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if self.symbols.is_empty() {
            write!(f, "Îµ")
        } else {
            write!(f, "{}", self.symbols.iter().format(" "))
        }
    }
}

impl Derivation {
    pub fn new(symbols: Vec<Symbol>) -> Self {
        Self { symbols }
    }

    pub fn symbols(&self) -> &[Symbol] {
        &self.symbols
    }
}

#[derive(Debug)]
pub struct DerivationGrammar {
    language: Language,
    start_symbol: String,
    derivation_rules: HashMap<String, Vec<Derivation>>,
}

impl Display for DerivationGrammar {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "Grammar for {}", self.language)?;
        write!(f, "Start symbol: <{}>", self.start_symbol)?;
        for (symbol, derivations) in &self.derivation_rules {
            writeln!(f, "{} :=", symbol)?;
            for derivation in derivations {
                writeln!(f, "  | {derivation}")?;
            }
            writeln!(f)?;
        }
        Ok(())
    }
}

impl DerivationGrammar {
    pub fn new(
        language: Language,
        start_symbol: String,
        derivation_rules: HashMap<String, Vec<Derivation>>,
    ) -> Self {
        Self {
            language,
            start_symbol,
            derivation_rules,
        }
    }

    pub fn derivation_rules(&self) -> &HashMap<String, Vec<Derivation>> {
        &self.derivation_rules
    }
}

impl DerivationGrammar {
    pub fn from_tree_sitter_grammar_json(
        language: Language,
        grammar_json: &str,
    ) -> Result<Self, CreationError> {
        let input_grammar =
            tree_sitter_generate::parse_grammar(grammar_json).map_err(CreationError::TreeSitter)?;
        let (syntax_grammar, lexical_grammar, _simple_aliases) =
            tree_sitter_generate::prepare_grammar(&input_grammar)
                .map_err(CreationError::TreeSitter)?;
        Self::from_tree_sitter_grammar(language, syntax_grammar, lexical_grammar)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum CreationError {
    #[error("Error occurred in tree-sitter: {0}")]
    TreeSitter(anyhow::Error),
    #[error("The provided grammar is empty")]
    EmptyGrammar,
    #[error("The grammar is missing a rule")]
    MissingRule,
}

#[derive(Debug)]
pub struct GrammarContext {
    grammar: DerivationGrammar,
    ts_language: tree_sitter::Language,
    derivation_fragments: HashMap<String, Vec<Vec<u8>>>,
}

impl GrammarContext {
    pub fn parse_source_code(
        &self,
        source_code: impl AsRef<[u8]>,
    ) -> Result<tree_sitter::Tree, tree_sitter::LanguageError> {
        let mut parser = tree_sitter::Parser::new();
        parser.set_language(&self.ts_language)?;
        let tree = parser.parse(source_code, None).expect("Garenteed by API");
        Ok(tree)
    }

    pub fn derivation_fragment(&self, node_kind: &str) -> impl Iterator<Item = &[u8]> {
        let Some(fragments) = self.derivation_fragments.get(node_kind) else {
            return Either::Left(std::iter::empty());
        };
        Either::Right(fragments.iter().map(|it| it.as_slice()))
    }
}

/// Extracts derivation fragments from the given source code using the provided parser.
///
/// This function parses the provided source code and traverses the resulting parse tree
/// to extract fragments of the code associated with each node type. The fragments are
/// grouped by their node types and returned as a `HashMap`.
///
/// # Arguments
///
/// * `code` - A byte slice representing the source code to be parsed.
/// * `parser` - A mutable reference to a `tree_sitter::Parser` used to parse the code.
///
/// # Returns
///
/// A `HashMap` where the keys are static string slices representing the node types,
/// and the values are vectors of byte slices representing the fragments of the code
/// associated with each node type.
pub fn extract_derivation_fragments<'c>(
    code: &'c [u8],
    parser: &mut tree_sitter::Parser,
) -> HashMap<&'static str, Vec<&'c [u8]>> {
    let Some(tree) = parser.parse(code, None) else {
        return HashMap::new();
    };

    tree.root_node()
        .iter_depth_first()
        .map(|it| {
            let kind = it.kind();
            let fragment = &code[it.byte_range()];
            (kind, fragment)
        })
        .into_group_map()
}

pub mod tree;

#[cfg(test)]
mod test {
    use crate::text_document::Language;

    use super::{extract_derivation_fragments, DerivationGrammar, C_GRAMMAR_JSON};

    const C_CODE: &str = r#"
    #include <stdio.h>
    #include <stdlib.h>

    const int x = 42;

    int main(int argc, char *argv[] "\n") {
        printf("Hello, world!\n");
        return 0;
    }
    "#;

    #[test]
    fn test_extract_derivation_fragments() {
        let mut parser = tree_sitter::Parser::new();
        let lang = tree_sitter_c::LANGUAGE.into();
        parser.set_language(&lang).unwrap();
        let fragments = extract_derivation_fragments(C_CODE.as_bytes(), &mut parser);
        for key in [
            "translation_unit",
            "function_definition",
            "declaration",
            "expression_statement",
            "call_expression",
            "string_literal",
            "number_literal",
        ] {
            assert!(fragments.contains_key(key), "{key} not found");
        }
        assert!(fragments["number_literal"].contains(&b"42".as_slice()));
    }

    #[test]
    fn load_derivation_grammar() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::C, C_GRAMMAR_JSON).unwrap();
        println!("{}", grammar);
    }
}
