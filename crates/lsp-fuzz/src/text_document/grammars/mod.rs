use core::fmt;
use std::{
    borrow::Cow,
    collections::HashMap,
    fmt::{Display, Formatter},
    marker::PhantomData,
    ops::Range,
};

use anyhow::bail;
pub mod tree;
use indexmap::{IndexMap, IndexSet};
use itertools::{Either, Itertools};
use libafl_bolts::rands::Rand;
use serde::{Deserialize, Serialize};
pub mod fragment_extraction;

use crate::stolen::tree_sitter_generate;

use super::Language;

#[derive(Debug)]
pub struct GrammarJson {
    _phantom: PhantomData<()>,
}

impl GrammarJson {
    /// The C grammar generated by tree-sitter
    pub const C: &str = include_str!("tree_sitter/c.json");

    /// The C++ grammar generated by tree-sitter
    pub const CPP: &str = include_str!("tree_sitter/cpp.json");

    /// The JavaScript grammar generated by tree-sitter
    pub const JAVASCRIPT: &str = include_str!("tree_sitter/javascript.json");

    /// The Ruby grammar generated by tree-sitter
    pub const RUBY: &str = include_str!("tree_sitter/ruby.json");

    /// The Rust grammar generated by tree-sitter
    pub const RUST: &str = include_str!("tree_sitter/rust.json");

    /// The Toml grammar generated by tree-sitter
    pub const TOML: &str = include_str!("tree_sitter/toml.json");
}

#[derive(Debug, Hash, PartialEq, Eq, Serialize, Deserialize, derive_more::Display)]
pub enum Terminal {
    #[display("\"{}\"", String::from_utf8_lossy(_0).escape_default())]
    Immediate(Vec<u8>),
    #[display("[{_0}]")]
    Named(String),
    #[display("({_0})")]
    Auxiliary(String),
}

#[derive(Debug, Hash, PartialEq, Eq, Serialize, Deserialize, derive_more::Display)]
pub enum Symbol {
    Terminal(Terminal),
    #[display("<{_0}>")]
    NonTerminal(String),
    #[display("<EOF>")]
    Eof,
}

#[derive(Debug, Hash, PartialEq, Eq, Serialize, Deserialize, derive_more::IntoIterator)]
pub struct Derivation {
    #[serde(flatten)]
    #[into_iterator(owned, ref, ref_mut)]
    symbols: Vec<Symbol>,
}

impl Display for Derivation {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        if self.symbols.is_empty() {
            write!(f, "Îµ")
        } else {
            write!(f, "{}", self.symbols.iter().format(" "))
        }
    }
}

impl Derivation {
    pub fn new(symbols: Vec<Symbol>) -> Self {
        Self { symbols }
    }

    pub fn symbols(&self) -> &[Symbol] {
        &self.symbols
    }
}

#[derive(Debug, PartialEq, Eq, Serialize, Deserialize, derive_more::Constructor)]
pub struct DerivationGrammar {
    language: Language,
    start_symbol: String,
    derivation_rules: IndexMap<String, IndexSet<Derivation>>,
}

impl Display for DerivationGrammar {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        writeln!(f, "Grammar for {}", self.language)?;
        writeln!(f, "Start symbol: <{}>", self.start_symbol)?;
        writeln!(f, "Production rules:")?;
        for (symbol, derivations) in &self.derivation_rules {
            writeln!(
                f,
                "<{}> ::=\n    {}\n",
                symbol,
                derivations.iter().format("\n  | ")
            )?;
        }
        writeln!(f)?;
        Ok(())
    }
}

impl DerivationGrammar {
    pub fn derivation_rules(&self) -> &IndexMap<String, IndexSet<Derivation>> {
        &self.derivation_rules
    }
}

impl DerivationGrammar {
    pub fn from_tree_sitter_grammar_json(
        language: Language,
        grammar_json: &str,
    ) -> Result<Self, CreationError> {
        let input_grammar =
            tree_sitter_generate::parse_grammar(grammar_json).map_err(CreationError::TreeSitter)?;
        let (syntax_grammar, lexical_grammar, aliases) =
            tree_sitter_generate::prepare_grammar(&input_grammar)
                .map_err(CreationError::TreeSitter)?;
        Self::from_tree_sitter_grammar(language, syntax_grammar, lexical_grammar, aliases)
    }

    pub fn validate(&self) -> Result<(), anyhow::Error> {
        for symbol in self.derivation_rules.values().flatten().flatten() {
            match symbol {
                Symbol::NonTerminal(ref name) if !self.derivation_rules.contains_key(name) => {
                    bail!("Missing rule for non-terminal symbol: {}", name);
                }
                _ => {}
            }
        }
        Ok(())
    }
}

#[derive(Debug, thiserror::Error)]
pub enum CreationError {
    #[error("Error occurred in tree-sitter: {0}")]
    TreeSitter(anyhow::Error),
    #[error("The provided grammar is empty")]
    EmptyGrammar,
    #[error("The grammar is missing a rule")]
    MissingRule,
}

#[derive(Debug, Serialize, Deserialize, derive_more::Constructor)]
pub struct DerivationFragments {
    code: Vec<u8>,
    fragments: HashMap<Cow<'static, str>, Vec<Range<usize>>>,
}

impl DerivationFragments {
    pub fn get(&self, node_kind: &str) -> Option<impl ExactSizeIterator<Item = &[u8]>> {
        let ranges = self.fragments.get(node_kind)?;
        Some(ranges.iter().cloned().map(|range| &self.code[range]))
    }
}

#[derive(Debug, Serialize, Deserialize, derive_more::Constructor)]
pub struct GrammarContext {
    grammar: DerivationGrammar,
    derivation_fragments: DerivationFragments,
}

impl GrammarContext {
    pub fn create_parser(&self) -> tree_sitter::Parser {
        let mut parser = tree_sitter::Parser::new();
        parser
            .set_language(&self.grammar.language.ts_language())
            .expect("Invalid tree-sitter language");
        parser
    }

    pub fn parse_source_code(
        &self,
        source_code: impl AsRef<[u8]>,
    ) -> Result<tree_sitter::Tree, tree_sitter::LanguageError> {
        let mut parser = self.create_parser();
        let tree = parser.parse(source_code, None).expect("Guaranteed by API");
        Ok(tree)
    }

    pub fn language(&self) -> Language {
        self.grammar.language
    }

    pub fn derivation_fragment(&self, node_kind: &str) -> impl ExactSizeIterator<Item = &[u8]> {
        if let Some(fragments) = self.derivation_fragments.get(node_kind) {
            Either::Right(fragments)
        } else {
            Either::Left(std::iter::empty())
        }
    }

    pub fn start_symbol_fragments(
        &self,
    ) -> Result<impl ExactSizeIterator<Item = &[u8]>, DerivationError> {
        self.derivation_fragments
            .get(&self.grammar.start_symbol)
            .ok_or(DerivationError::InvalidGrammar)
    }

    pub fn generate_node(
        &self,
        node_kind: &str,
        rand: &mut impl Rand,
        max_depth: Option<usize>,
    ) -> Result<Vec<u8>, DerivationError> {
        let derivation_fragments = self.derivation_fragment(node_kind);
        let has_derivation_rule = self.grammar.derivation_rules.contains_key(node_kind);
        let has_derivation_fragments = derivation_fragments.len() > 0;
        let depth_limit_reached = max_depth.is_some_and(|it| it == 0);
        let should_derive = match (
            depth_limit_reached,
            has_derivation_rule,
            has_derivation_fragments,
        ) {
            (true, _, false) => return Err(DerivationError::DepthLimitReached),
            (_, false, true) => false,
            (true, _, true) => false,
            (false, true, false) => true,
            (false, true, true) => rand.coinflip(0.5),
            (false, false, false) => return Err(DerivationError::InvalidGrammar),
        };
        if should_derive {
            let derivation_rules = self
                .grammar
                .derivation_rules()
                .get(node_kind)
                .expect("We checked that the rule is available");
            let rule = rand
                .choose(derivation_rules)
                .ok_or(DerivationError::InvalidGrammar)?;
            rule.into_iter()
                .map(|symbol| match symbol {
                    Symbol::NonTerminal(ref name) => {
                        self.generate_node(name, rand, max_depth.map(|it| it - 1))
                    }
                    Symbol::Terminal(ref term) => match term {
                        Terminal::Immediate(content) => Ok(content.to_vec()),
                        Terminal::Named(name) | Terminal::Auxiliary(name) => {
                            let fragments = self.derivation_fragment(name);
                            let fragment = rand
                                .choose(fragments)
                                .ok_or(DerivationError::InvalidGrammar)?;
                            Ok(fragment.to_vec())
                        }
                    },
                    Symbol::Eof => Ok(Vec::default()),
                })
                .flatten_ok()
                .collect::<Result<Vec<_>, _>>()
        } else {
            let fragments = self.derivation_fragment(node_kind);
            let fragment = rand
                .choose(fragments)
                .ok_or(DerivationError::InvalidGrammar)?;
            Ok(fragment.to_vec())
        }
    }
}

#[derive(Debug, thiserror::Error)]
pub enum DerivationError {
    #[error("The depth limit has been reached")]
    DepthLimitReached,
    #[error("The grammar is invalid")]
    InvalidGrammar,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn load_derivation_grammar_c() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::C, GrammarJson::C).unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }

    #[test]
    fn load_derivation_grammar_cpp() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::CPlusPlus, GrammarJson::CPP)
                .unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }

    #[test]
    fn load_derivation_grammar_javascript() {
        let grammar = DerivationGrammar::from_tree_sitter_grammar_json(
            Language::JavaScript,
            GrammarJson::JAVASCRIPT,
        )
        .unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }

    #[test]
    fn load_derivation_grammar_rust() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::Rust, GrammarJson::RUST)
                .unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }

    #[test]
    fn load_derivation_grammar_toml() {
        let grammar =
            DerivationGrammar::from_tree_sitter_grammar_json(Language::Toml, GrammarJson::TOML)
                .unwrap();
        eprintln!("{}", grammar);
        grammar.validate().unwrap();
    }
}
